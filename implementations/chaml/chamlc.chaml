IO=self.import("io");

//env=self.import("system").env; /// Location where UNIX enviroment variables are found

tr=self.import("./lib/syntax-tree");
tk=self.import("./lib/syntax-tokens");

//If I get stuck, here's some URLs for help 
//https://en.wikipedia.org/wiki/Recursive_descent_parser

runFile=Func([Str()],Null());

tokenify=(getNextLine,error)=>{
	Symbol=Type();

	CheckerBuiltIn={
		a={};
		a.builtIn=true;
		a.action=(line,buffer)=>not(a.regexp.matches(buffer+Str(line[0])));
		self.ret(a);
	};
	checkers=[
		{
			a=CheckerBuiltIn();
			a.regexp="\\/\\/.*\n";
			a.name="comment";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="\\/\\*(.*)?\\*\\/";
			a.name="multicomment";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			//NOTE: because we are making a regexp inside a string, escapes must be doubled
			a.regexp="[01-9][01-9_]*(\\.[01-9_]*)?";
			a.name="num";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="[a-zA-Z_$][a-zA-Z01-9_$]*";//add unicode support later
			a.name="identifier";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="{";
			a.name="openC";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="}";
			a.name="closeC";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="\\(";
			a.name="openP";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="\\)";
			a.name="closeP";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="\s*";
			a.name="whitespace";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="=>";
			a.name="lamda";//This may not be the correct name
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="=";
			a.name="set";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp=";";
			a.name="semicolon";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp=",";
			a.name="comma";
			self.ret(a);
		}(),
	].each((i,v) {
		Symbol[i]=v.name;
		Symbol[v.name]=i;
	});

	sym=Symbol();
	line=getNextLine();
	oreq=(a1,a2)=>(b1,b2)=>eq(a1,a2).or(eq(b1,b2));
	nextSym={
		buffer="";
		isNotValidSymbol=true;
		while(()=>isNotValidSymbol,{
			if(oreq(buffer.len(),0)(sym,-1),{
				buffer=Str(line[0]);
				line=line.slice(1);
			});
			s=self;
			if(eq(line.len(),0),{
				line=getNextLine();
				s.ret(true);//this is basically a continue. Returning false is a break;
			});
			index=0;
			sym=-1;
			while(()=>index<checkers.len(),{
				if (RegExp(checkers[index].regexp).matches(buffer),{
					if(checkers[index].action(line,buffer),{
						sym=Symbol[checkers[index].name];
						index=checkers.len();
						isNotValidSymbol=false;
					});
					if (oreq(sym,Symbol["comment"])(sym,Symbol["multicomment"]),{
						buffer="";
						line=getNextLine();
						isNotValidSymbol=true;
					});
				});
				index.up1();
			});
		});
	};

	accept=s=>{
		isEq=eq(sym,s);
		if(isEq,{
			nextSym();
		});
		self.ret(isEq);
	};
	expect=s=>{
		a=accept(s);
		if(not(a),{
			error("Unexpected symbol \""+Symbol[sym]+"\"\nWas expecting symbol \""+Symbol[s]+"\" instead.");
		});
		self.ret(a);
	};
	reject=(s,reason)=>{
		isEq=eq(sym,s);
		if(isEq,{
			error("Rejected symbol \""+s"\"\n"+reason);
		});
		self.ret(isEq);
	};

	block=a=>null;//Defined here to enable statement to work with functions

	/**
	 * It's a function
	 * (named this way to avoid all ambiguity)
	 * @parem numberOfArguments the numberOfArguments that it took. Used for syntax stuff
	 */
	afunction=(numberOfArguments,preface)=>{//TODO
		if(preface.and(lte(numberOfArguments,1)),{
			expect(Symbol["lamda"]);
		},()=>if(gte(numberOfArguments,2),{
			accept(Symbol["lamda"]);
		},{
			reject(Symbol["lamda"],
				"A zero argument function without any other preface indicators must not have this operator.\nTry removing it, or prefixing it with parentheses");
		}));
		//TODO
	};

	/**
	 * Something that goes inside a variable. Probabbly needs a better name.
	 */
	statement={//TODO
		s=self;
		if(accept(Symbol["openP"]),{
			accept(Symbol["whitespace"]);
			itsAFunc=false;
			argCount=0;
			if(accept(Symbol["identifier"]),{//Is it a function?
				accept(Symbol["whitespace"]);
				if(accept(Symbol["comma"]),{//two or more arg function
					accept(Symbol["whitespace"]);
					argCount=1;
					while({
						accept(Symbol["whitespace"]);
						s=self;
						if (eq(argCount,1),{
							s.ret(accept(Symbol["identifier"]));
						},{
							s.ret(expect(Symbol["identifier"]));
						});
					},{
						argCount.up1();//think a++ ++a is Num.up1(a);
						accept(Symbol["whitespace"]);
						self.ret(accept(Symbol["comma"]));
					});
				},()=>if(accept(Symbol["closeP"]),{//Single arg function
					itsAFunc=true;
					argCount=1;
					accept(Symbol["whitespace"]);
				}));
			},()=>if(accept(Symbol["closeP"]),{//the only thing this could be is a one line function with no args
				itsAFunc=true;
				accept(Symbol["whitespace"]);
			},s));// I guess it's just a paren set
			accept(Symbol["closeP"]);
			if(itsAFunc,()=> afunction(count,true));
		},{//TODO

		});
	};

	/**
	 * A list of statements. Could either be arguments or an arr
	 */
	statementList={
		ranOnce=false;
		while({
			self.ret(or(not(ranOnce),eq(sym,Symbol["comma"])));
		},{
			if(ranOnce,()=>expect(Symbol["comma"]));
			accept(Symbol["whitespace"]);
			statement();
			accept(Symbol["whitespace"]);
			ranOnce=true;
		});
	};

	/**
	 * Think of it like a single line of a function.
	 */
	action={
		expect(Symbol["identifier"]);
		accept(Symbol["whitespace"]);
		if(accept(Symbol["set"]),//set or change a value
			statement,
		()=>if(accept(Symbol["openP"]),{//call a function
			statementList();
			expect(Symbol["closeP"]);
		}));
		expect(Symbol["semicolon"]);
	};

	/**
	 * A function, or the internals of a program
	 * @param needsCurls if true, it expects curlys
	 */
	block=needsCurls=>{//A function, or a program
		needsCurls=false;
		if(notoutermost,{
			needsCurls=accept(Symbol["openC"]);
		});
		while({
			accept(Symbol["whitespace"]);
			self.ret@eq(sym,Symbol["identifier"]);
		},action);
		if(needsCurls,()=>expect(Symbol["closeC"]));
	};

	/**
	 * expect a program. (To be called only once. self-destructive)
	 */
	program={
		nextSym();
		block(false);
		self={};
	};
};

makeTree=(tokens)=>{

};

readFile=(name,error)=>{
	file=IO.in.openFile(name);/// The file that is open
	s=self;
	tree=makeTree(
		tokenify(() => file.readLine(),error)
	);
};

compileFile=(name,error)=>{
	tree=readFile(name,val=>{
		error("Compile error in "+name+" :\n"+er);
	},val=>{
		error("Compile error: "+er);
	});//do stuff with tree
}

runFile=name=>{
	runTree(readFile(name,val=>{
		error("Interpreter error in "+name+" :\n"+er);
	}));
}

self.ret(args => compileFile(args[args.length-1],IO.out.err));
