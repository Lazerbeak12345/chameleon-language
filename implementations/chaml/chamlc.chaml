IO=self.import("io");

//env=self.import("system").env; /// Location where UNIX enviroment variables are found

tr=self.import("./lib/syntax-tree");
tk=self.import("./lib/syntax-tokens");

//If I get stuck, here's some URLs for help 
//https://en.wikipedia.org/wiki/Recursive_descent_parser

runFile=Func([Str()],Null());

tokenify=(getNextLine,error)=>{
	Symbol=Type();

	CheckerBuiltIn={
		a={};
		a.builtIn=true;
		a.action=(line,buffer)=>not(a.regexp.matches(buffer+Str(line[0])));
		self.ret(a);
	};
	checkers=[
		{
			a=CheckerBuiltIn();
			a.regexp="\\/\\/.*\n";
			a.name="comment";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="\\/\\*(.*)?\\*\\/";
			a.name="multicomment";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			//NOTE: because we are making a regexp inside a string, escapes must be doubled
			a.regexp="[01-9][01-9_]*(\\.[01-9_]*)?";
			a.name="num";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="[a-zA-Z_$][a-zA-Z01-9_$]*";//add unicode support later
			a.name="identifier";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="{";
			a.name="openC";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="}";
			a.name="closeC";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="\\(";
			a.name="openP";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="\\)";
			a.name="closeP";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="\s*";
			a.name="whitespace";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="==";
			a.name="eq";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp="=";
			a.name="set";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp=";";
			a.name="semicolon";
			self.ret(a);
		}(),
		{
			a=CheckerBuiltIn();
			a.regexp=",";
			a.name="comma";
			self.ret(a);
		}(),
	].each((i,v) {
		Symbol[i]=v.name;
		Symbol[v.name]=i;
	});

	sym=Symbol();
	line=getNextLine();
	nextSym={
		buffer="";
		isNotValidSymbol=true;
		while(()=>isNotValidSymbol,{
			if(or(buffer.len()==0,sym==-1),{
				buffer=Str(line[0]);
				line=line.slice(1);
			});
			s=self;
			if(line.len()==0,{
				line=getNextLine();
				s.ret(true);//this is basically a continue. Returning false is a break;
			});
			index=0;
			sym=-1;
			while(()=>index<checkers.len(),{
				if (RegExp(checkers[index].regexp).matches(buffer),{
					if(checkers[index].action(line,buffer),{
						sym=Symbol[checkers[index].name];
						index=checkers.len();
						isNotValidSymbol=false;
					});
					if (or(sym==Symbol["comment"],sym==Symbol["multicomment"]),{
						buffer="";
						line=getNextLine();
						isNotValidSymbol=true;
					});
				});
				index++;
			});
		});
	};

	accept=s=>{
		isEq=sym==s;
		if(isEq,{
			nextSym();
		});
		self.ret(isEq);
	};
	expect=s=>{
		a=accept(s);
		if(not(a),{
			error("Unexpected symbol \""+Symbol[sym]+"\"\nWas expecting symbol \""+Symbol[s]+"\" instead.");
		});
		self.ret(a);
	};
	reject=(s,reason)=>{
		isEq=sym==s;
		if(isEq,{
			error("Rejected symbol \""+s"\"\n"+reason);
		});
		self.ret(isEq);
	};

	block=a=>null;//Defined here to enable statement to work with functions

	statement={
		//TODO
	};

	statementList={
		ranOnce=false;
		while({
			self.ret(or(not(ranOnce),));
		},{
			if(ranOnce,()=>expect(Symbol["comma"]));
			accept(Symbol["whitespace"]);
			statement();
			accept(Symbol["whitespace"]);
			ranOnce=true;
		});
	};

	action={
		expect(Symbol["identifier"]);
		accept(Symbol["whitespace"]);
		if(accept(Symbol["set"]),//set/change a value
			statement,
		()=>if(accept(Symbol["openP"]),{//call a function
			statementList();
			expect(Symbol["closeP"]);
		}));
		expect(Symbol["semicolon"]);
	};

	block=notoutermost=>{
		needsClose=false;
		if(notoutermost,{
			needsClose=accept(Symbol["openC"]);
		});
		while({
			accept(Symbol["whitespace"]);
			self.ret(sym==Symbol["identifier"]);
		},action);
		if(needsClose,()=>expect(Symbol["closeC"]));
	};

	program={
		nextSym();
		block(false);
	};
};

makeTree=(tokens)=>{

};

readFile=(name,error)=>{
	file=IO.in.openFile(name);/// The file that is open
	s=self;
	tree=makeTree(
		tokenify(() => file.readLine(),error)
	);
};

compileFile=(name,error)=>{
	tree=readFile(name,val=>{
		error("Compile error in "+name+" :\n"+er);
	},val=>{
		error("Compile error: "+er);
	});//do stuff with tree
}

runFile=name=>{
	runTree(readFile(name,val=>{
		error("Interpreter error in "+name+" :\n"+er);
	}));
}

self.ret(args => compileFile(args[args.length-1],IO.out.err));
