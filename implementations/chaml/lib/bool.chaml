/**
 * An implimentation of Bool, as inspired by page 36 of Benjamin C. Pierce's
 * "Type Systems for Programming Languages," January 15, 2000 draft.
 * 
 * Note that to the end programmer, they won't ever know that this system, in
 * fact, does not have a native bool, by default, and uses this.
 */

Bool={};//Returns nothing given nothing.

//These two lines are almost directly converted from a lamda satement in Peirce's book, but with an ext to Bool
Bool.t=((a,b)=>a).ext(Bool);//extends bool for typing reasons
Bool.f=((a,b)=>b).ext(Bool);

Bool.and=(a,b)=>a(b,Bool.f);
Bool.t.and=b=>Bool.and(Bool.t,b);
Bool.f.and=b=>Bool.and(Bool.f,b);

Bool.or=(a,b)=>a(Bool.f,b);
Bool.t.or=b=>Bool.or(Bool.t,b);
Bool.f.or=b=>Bool.or(Bool.f,b);

Bool.xor=(a,b)=>a(b(Bool.f,Bool.t),b(Bool.t,Bool.f));
Bool.t.xor=b=>Bool.xor(Bool.t,b);
Bool.f.xor=b=>Bool.xor(Bool.f,b);

Bool.not=a=>a(Bool.f,Bool.t);
Bool.t.not=()=>Bool.f;
Bool.f.not=()=>Bool.t;

Bool.if=(b,f) {
	v=b(f,{})();//Capture the value in v
	state=b.not();
	out=()=>v;
	out.elif=(b,f) {
		state=state.and(b);
		v=state(f,{})();//update the value
		=<out;
	};
	out~out.elif;//Overload out to take elif's args too (will make it act like elif in that case)
	out.else=f=>{
		v=state(f,{})();//update the value
	};
	out~out.else;
	=< out;
};
Bool.if~(a,b,c)=>Bool.if(a,b)(c);
Bool.if~a=>b=>Bool.if(a,b);//Wait for the next arg

Bool.while=(b,f,d) {
	re=()=>Bool.while(b,f,d);         //Defined the recursor up here for minimum stack
	=< Bool(b())(                     //Get the return of the bool satement, casting it to a bool
		{
			r=f();                    //Get the return of the function satement
			=< r.instanceOf(Nothing)( //Pass up the result
				()=>Bool.t;,          //If it didn't return anything, act like it returned true
				()=>Bool(r);          //Or else return whatever it did, casted to a bool
			)()(
				re,                   //If it was true, pass the recursive func from above
				d                     //Or else pass the "done"
			);
		},
		()=>d;                        //or else pass a wrapped done
	)()();                            //call the getter and the recursor or done func
};
Bool.while~(b,f)=>Bool.while(b,f,{});//The done is optional

Bool~v=>{
	=< v.instanceOf(Bool)({
		=<v;
	},{
		=< v.instanceOf(Nothing)({
			=<Bool.f;
		},{
			=<v.to.Bool();//This may throw an error
		})();
	})();
};
Bool.t.to.Bool=()=>Bool.t;//Gets .to from Func, it's natural parent.
Bool.f.to.Bool=()=>Bool.f;

=<Bool;
